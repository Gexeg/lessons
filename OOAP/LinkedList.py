'''
2.2. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?
Другим вариантом достижения хвоста будет повторение команды right(). Сложность выполнения такой задачи зависит от количества элементов в списке, тогда как
сложность достижения хвоста отдельной командой tail() постоянна.

2.3. Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?
В текущем описании операция find() перемещает курсор на следующий узел с искомым значением. Можно собрать все узлы повторением команды.
В первоначальной реализации не было предусмотрено курсора, обход списка начинался заново и требовался отдельный запрос, собирающий все узлы за 1 пробег.

abstract class LinkedList<T>

    public const int RIGHT_NONE = 0; // right() ещё не вызывалась
    public const int RIGHT_OK = 1; // последняя right() отработала нормально
    public const int RIGHT_ERR = 2; // достинут конец списка либо в списке отсутствуют узлы

    public const int GET_NONE = 0; // get() ещё не вызывалась
    public const int GET_OK = 1; // последняя get() отработала нормально
    public const int GET_ERR = 2; // в списке отсутствуют узлы

    public const int PUT_NONE = 0; // put() ещё не вызывалась
    public const int PUT_OK = 1; // последняя put() отработала нормально
    public const int PUT_ERR = 2; // в списке отсутствуют узлы

    public const int REMOVE_NONE = 0; // remove() ещё не вызывалась
    public const int REMOVE_OK = 1; // последняя remove() отработала нормально
    public const int REMOVE_ERR = 2; // в списке отсутствуют узлы

    public const int REPLACE_NONE = 0; // replace() ещё не вызывалась
    public const int REPLACE_OK = 1; // последняя replace() отработала нормально
    public const int REPLACE_ERR = 2; // в списке отсутствуют узлы

    public const int FIND_NONE = 0; // find() ещё не вызывалась
    public const int FIND_OK = 1; // последняя find() отработала нормально
    public const int FIND_ERR = 2; // достинут конец списка либо в списке отсутствуют узлы

    // КОНСТРУКТОР
    // постусловие: создан новый пустой связный список. 
    public LinkedList<T> LinkedList(); 
    // конец конструктора


    // КОМАНДЫ
    // установить курсор на начало списка
    // предусловие: список не пустой
    // постусловие: изменено положение курсора
    public void head()

    // установить курсор в конец списка
    // предусловие: список не пустой
    // постусловие: изменено положение курсора
    public void tail()

    // сдвинуть курсор вправо
    // предусловие: курсор установлен на какой-либо узел
    // предусловие: курсор расопложен не в хвосте
    // постусловие: изменено положение курсора
    public void right()

    // вставить следом за текущим узлом узел со значением
    // предусловие: курсор установлен на какой-либо узел
    // постусловие: в список добавлен узел. Если курсор был расположен в хвосте, то узел становится новым хвостом
    public void put_right(T value)

    // вставить перед текущим узлом узел со значением
    // предусловие: курсор установлен на какой-либо узел
    // постусловие: в список добавлен узел. Если курсор был расположен в голове, то узел становится новой головой
    public void put_left(T value)

    // удалить текущий узел.
    // предусловие: курсор установлен на какой-либо узел
    // постусловие: узел удален из списка
    // постусловие: если есть сосед справа, курсор смещается к нему, иначе курсор смещается к левому соседу, если он есть.
    // если это был последний узел, курсор больше не показывает на какой-либо узел
    public void remove()

    // очистить список
    // постусловие: из списка удаляются все значения, все статусы устанавливаются на *_NONE
    public void clear()

    // добавить новый узел в хвост списка
    // постусловие: в хвост списка добавлен узел
    public void add_tail(T value)

    // заменить значение текущего узла
    // предусловие: курсор установлен на какой-либо узел
    // постусловие: значение этого узла заменено на входящее
    public void replace (T value)

    // установить курсор на следующий (по отношению к текушему) узел с заданным значением
    // предусловие: курсор установлен на какой-либо узел
    // предусловие: после этого узла есть следующий узел с заданным значением
    // постусловие: курсор перемещен на следующий узел с заданным значением
    public void find(T value)

    // удалить в списке все узлы с заданным значением 
    // постусловие: в списке удалены все узлы с заданным значением
    public void remove_all(T value)


    // ЗАПРОСЫ
    // курсор находится в начале списка?
    public void is_head()

    // курсор находится в конце списка?
    public void is_tail()

    // установлен ли курсор на какой-либо узел в списке (равносильно "есть ли список?")
    public void is_value()

    // посчитать количество узлов в списке
    public size()

    // получить значение текущего узла
    // предусловие: курсор установлен на какой-либо узел
    public void get()

    // дополнительные запросы:
    public int get_right_status(); // возвращает значение RIGHT_*
    public int get_put_status(); // возвращает значение PUT_*
    public int get_get_status(); // возвращает значение GET_*
    public int get_remove_status(); // возвращает значение REMOVE_*
    public int get_replace_status(); // возвращает значение REPLACE_*
    public int get_find_status(); // возвращает значение FIND_*
'''
