"""
Задание 10.
Если используемый вами язык программирования допускает множественное наследование,
постройте небольшую иерархию, используя уже готовые General и Any, и замкните её снизу классом None.
Приведите пример полиморфного использования Void.
"""

from ClassHierarchy4 import General, Any


# Как я понял, главный смысл Void - замыкать оставленные без потомков, а значит нам нужно несколько потомков базового
# класса General
class Beta(General):
    pass

# сейчас я просто соберу листья в список вручную, в дальнейшем можно сделать скрипт, который по директориям собирает классы
# перед запуском проекта и проверяет __subclasses__, чтобы узнать потомков, например. Всех без потомков будем собирать
# в этот список и определять как предков к Void()


need_to_be_closed = [Beta, Any]


class Void(Beta, Any):
    pass


GLOBAL_NONE = Void

# Как это реализовать то вроде сообразил, но пока не могу понять цель:
# Почему именно нужно собирать все классы в наследнике, для организации None и чем это лучше пустого класса без
# предков-потомков? Вроде наоборот порождает лишние проблемы с отслеживанием x = Void, x.foo()

"""
Ответ:
Идея замкнуть в наследнике в том, что иначе не будет работать полиморфизм -- класс для этого должен входить в общую
систему типов. это в питоне нету таких проверок, поэтому можно взять сторонний класс.
Если вызываем foo() для пустого объекта, это одна из известных болей ООП, на курсе про это есть.
"""

# По примеру: насколько знаю, В C подобное значение используется чтобы показать, что функция не принимает
# аргументов или не возвращает. Для возврщения мы можем использовать аннотации mypy, но в рамках Python это
# Будет иметь не очень много смысла
from typing import Type


def foo() -> Type[Void]:
    print('Ничего не принимаю, ничего не возвращу')
    return Void

# Если использовать как замену None,то вижу только примеры с проверкой типа вроде


a = General()

if a == Void or a == GLOBAL_NONE:
    'do somthing'


"""
Задание 11.
Добавьте в классы General и Any попытку присваивания и её реализацию.
"""

# Если я правильно понял, это будет выглядеть как-то вот так:
# Не совсем корректно, но чтобы не переписывать весь класс, унаследуюсь от него.


class General2(General):

    @classmethod
    def assignment_attempt(cls, target, source):
        """ Попытка присвоить значение, предворяемая проверкой типа цели и источника.
        
        >>> a = General2()
        >>> b = Any()
        >>> a = General2.assignment_attempt(a, b)
        >>> a
        <class '__main__.Void'>
        
        >>> a = General2()
        >>> b = General2()
        >>> b.value = 10
        >>> a = General2.assignment_attempt(a, b)
        >>> a
        <__main__.General2 object at 0x7fcc9e8deeb0>
        >>> a.value
        10
        
        :param target: целевой объект
        :type target: General2
        :param source: объект источник
        :type source: General2
        """
        if isinstance(target, cls) and isinstance(source, cls):
            target.value = source.value
            return target
        else:
            return GLOBAL_NONE

# Так мы можем определить значение какого-то атрибута только при соответствии типов.


"""
Задание 12.
Разберитесь, какие из четырёх вариантов скрытия методов доступны в используемом вами языке программирования.
Приведите примеры кода для каждого из доступных вариантов.

Всего существует четыре варианта скрытия метода:
1. метод публичен в родительском классе А и публичен в его потомке B;
2. метод публичен в родительском классе А и скрыт в его потомке B;
3. метод скрыт в родительском классе А и публичен в его потомке B;
4. метод скрыт в родительском классе А и скрыт в его потомке B.
"""

# В Python есть псевдоприватные методы, которые выделяются двойной землей перед названием метода
# но по факту они лишь дописывают имя класса с _ перед названием метода и точно так же наследуются.


class PrivateMethodsTest():
    def __almost_private(self):
        print('Don\'t touch me')

    def _recomended_private(self):
        print('Don\'t touch me, please')
 

class TestChild(PrivateMethodsTest):        
    """
    >>> dir(TestChild)
    ['_PrivateMethodsTest__almost_private',
     '__class__', '__delattr__', '__dict__', '__dir__', 
    '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__',
    '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
    '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
     '_recomended_private']
    """
    pass

# Если мы принимаем, что рекомендация `_` равна приватности, то в Python можно поддерживается как раз 1 и 4 варианты,
# при котором приватный метод остается приватным в наследнике.
