"Задание 1."
"Примеры кода с наследованием, композицией и полиморфизмом."

class Engine():
    power = 0

    def get_boost(self):
        message = 'The car coughed up smoke. Nothing happens.'
        return (message, self.power)

# Оба класса двигателя являются наследниками базового класса Engine и изменяют его атрибуты либо методы.
class BaseEngine(Engine):
    power = 100


class CoolEngine(Engine):
    power = 150

    def get_boost(self):
        message = 'Car blows flame and accelerates!'
        return (message, self.power * 1.5)

# Класс Car использует композицию и сохраняет у себя в атрибутах доступ к объекту класса Engine.
# Насколько я понял определение и примеры, полиморфизм здесь - это способность класса Car принимать
# и взаимодействовать с любым объектом класса Engine, пока он обеспечивает доступ к закрепленным контрактом методам.

class Car():
    def __init__(self, engine):
        self.engine = engine
    
    def accelerate(self):
        pass

    def get_boost(self):
        message, power = self.engine.get_boost()
        print(message)
        return power

"Задание 2."
"Напишите небольшой пример кода с комментариями, "
"где в наследовании применяется как расширение класса-родителя, так и специализация класса-родителя."


# Стандартный класс очереди имеет только возможность добавить элемент в начало и получить последний элемент очереди
class Queue():
    def add_head(self, smth):
        pass

    def get_tail(self):
        pass

# Класс Deque расширяет свой родительский класс, дополняя возможностью получить последний добавленный элемент.
# По сути теперь её можно использовать как стек 
class Deque(Queue):
    def get_head(self):
        pass


# TaskDeque специализирует область применения класса Deque. Предполагается, что этот класс будет работать с 
# типом данных Task и валидировать их перед поступлением в очередь.
class TaskDeque(Deque):
    def __validate_task(self, task):
        return True

    def add_head(self, task):
        if self.__validate_task(task):
            super().add_head(task)

"Задание 3."
"Расскажите, как в выбранном вами языке программирования поддерживается концепция 'класс как модуль'."

# Python позволяет сохранять классы в модулях, модули группировать в пакеты. Во время импорта можно импортировать
# как класс внутри модуля, так и модуль и пакет, содержащий модули и работать с ними как с отдельной сущьностью.
# При первом импорте будет исполнена процедура запуска модуля, 
# которая заключается в последовательном выполнении строк кода в соответствующем модуле. В дальнейшем этот код переиспользуется.
